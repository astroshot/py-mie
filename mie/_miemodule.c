/* File: _miemodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Thu Mar 15 16:51:05 2018
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include "fortranobject.h"
/*need_includes0*/

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *_mie_error;
static PyObject *_mie_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
typedef struct {double r,i;} complex_double;
typedef struct {float r,i;} complex_float;

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#define pyobj_from_complex_float1(v) (PyComplex_FromDoubles(v.r,v.i))
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int complex_double_from_pyobj(complex_double* v,PyObject *obj,const char *errmess) {
    Py_complex c;
    if (PyComplex_Check(obj)) {
        c=PyComplex_AsCComplex(obj);
        (*v).r=c.real, (*v).i=c.imag;
        return 1;
    }
    if (PyArray_IsScalar(obj, ComplexFloating)) {
        if (PyArray_IsScalar(obj, CFloat)) {
            npy_cfloat new;
            PyArray_ScalarAsCtype(obj, &new);
            (*v).r = (double)new.real;
            (*v).i = (double)new.imag;
        }
        else if (PyArray_IsScalar(obj, CLongDouble)) {
            npy_clongdouble new;
            PyArray_ScalarAsCtype(obj, &new);
            (*v).r = (double)new.real;
            (*v).i = (double)new.imag;
        }
        else { /* if (PyArray_IsScalar(obj, CDouble)) */
            PyArray_ScalarAsCtype(obj, v);
        }
        return 1;
    }
    if (PyArray_CheckScalar(obj)) { /* 0-dim array or still array scalar */
        PyObject *arr;
        if (PyArray_Check(obj)) {
            arr = PyArray_Cast((PyArrayObject *)obj, NPY_CDOUBLE);
        }
        else {
            arr = PyArray_FromScalar(obj, PyArray_DescrFromType(NPY_CDOUBLE));
        }
        if (arr==NULL) return 0;
        (*v).r = ((npy_cdouble *)PyArray_DATA(arr))->real;
        (*v).i = ((npy_cdouble *)PyArray_DATA(arr))->imag;
        return 1;
    }
    /* Python does not provide PyNumber_Complex function :-( */
    (*v).i=0.0;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        (*v).r = PyFloat_AsDouble(obj);
#else
        (*v).r = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    if (PyInt_Check(obj)) {
        (*v).r = (double)PyInt_AS_LONG(obj);
        return 1;
    }
    if (PyLong_Check(obj)) {
        (*v).r = PyLong_AsDouble(obj);
        return (!PyErr_Occurred());
    }
    if (PySequence_Check(obj) && !(PyString_Check(obj) || PyUnicode_Check(obj))) {
        PyObject *tmp = PySequence_GetItem(obj,0);
        if (tmp) {
            if (complex_double_from_pyobj(v,tmp,errmess)) {
                Py_DECREF(tmp);
                return 1;
            }
            Py_DECREF(tmp);
        }
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL)
            err = PyExc_TypeError;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        *v = PyFloat_AsDouble(obj);
#else
        *v = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    tmp = PyNumber_Float(obj);
    if (tmp) {
#ifdef __sgi
        *v = PyFloat_AsDouble(tmp);
#else
        *v = PyFloat_AS_DOUBLE(tmp);
#endif
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = _mie_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int complex_float_from_pyobj(complex_float* v,PyObject *obj,const char *errmess) {
    complex_double cd={0.0,0.0};
    if (complex_double_from_pyobj(&cd,obj,errmess)) {
        (*v).r = (float)cd.r;
        (*v).i = (float)cd.i;
        return 1;
    }
    return 0;
}

static int float_from_pyobj(float* v,PyObject *obj,const char *errmess) {
    double d=0.0;
    if (double_from_pyobj(&d,obj,errmess)) {
        *v = (float)d;
        return 1;
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/******************************** test_double ********************************/
static char doc_f2py_rout__mie_kinds_module_test_double[] = "\
test_double(x)\n\nWrapper for ``test_double``.\
\n\nParameters\n----------\n"
"x : input float";
/*  */
static PyObject *f2py_rout__mie_kinds_module_test_double(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double x = 0;
  PyObject *x_capi = Py_None;
  static char *capi_kwlist[] = {"x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:_mie.kinds_module.test_double",\
    capi_kwlist,&x_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x */
    f2py_success = double_from_pyobj(&x,x_capi,"_mie.kinds_module.test_double() 1st argument (x) can't be converted to double");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of x*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of test_double *****************************/

/******************************** test_complex ********************************/
static char doc_f2py_rout__mie_kinds_module_test_complex[] = "\
test_complex(x)\n\nWrapper for ``test_complex``.\
\n\nParameters\n----------\n"
"x : input complex";
/*  */
static PyObject *f2py_rout__mie_kinds_module_test_complex(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(complex_float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  complex_float x;
  PyObject *x_capi = Py_None;
  static char *capi_kwlist[] = {"x",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:_mie.kinds_module.test_complex",\
    capi_kwlist,&x_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x */
    f2py_success = complex_float_from_pyobj(&x,x_capi,"_mie.kinds_module.test_complex() 1st argument (x) can't be converted to complex_float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  }  /*if (f2py_success) of x frompyobj*/
  /* End of cleaning variable x */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of test_complex ****************************/

/******************************** bhmie_driver ********************************/
static char doc_f2py_rout__mie_bhmie_module_bhmie_driver[] = "\
qext,qsca,qgsa = bhmie_driver(radius,refr_ind,wavelength)\n\nWrapper for ``bhmie_driver``.\
\n\nParameters\n----------\n"
"radius : input float\n"
"refr_ind : input complex\n"
"wavelength : input float\n"
"\nReturns\n-------\n"
"qext : float\n"
"qsca : float\n"
"qgsa : float";
/*  */
static PyObject *f2py_rout__mie_bhmie_module_bhmie_driver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,complex_float*,double*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double radius = 0;
  PyObject *radius_capi = Py_None;
  complex_float refr_ind;
  PyObject *refr_ind_capi = Py_None;
  double wavelength = 0;
  PyObject *wavelength_capi = Py_None;
  float qext = 0;
  float qsca = 0;
  float qgsa = 0;
  static char *capi_kwlist[] = {"radius","refr_ind","wavelength",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:_mie.bhmie_module.bhmie_driver",\
    capi_kwlist,&radius_capi,&refr_ind_capi,&wavelength_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable radius */
    f2py_success = double_from_pyobj(&radius,radius_capi,"_mie.bhmie_module.bhmie_driver() 1st argument (radius) can't be converted to double");
  if (f2py_success) {
  /* Processing variable refr_ind */
    f2py_success = complex_float_from_pyobj(&refr_ind,refr_ind_capi,"_mie.bhmie_module.bhmie_driver() 2nd argument (refr_ind) can't be converted to complex_float");
  if (f2py_success) {
  /* Processing variable wavelength */
    f2py_success = double_from_pyobj(&wavelength,wavelength_capi,"_mie.bhmie_module.bhmie_driver() 3rd argument (wavelength) can't be converted to double");
  if (f2py_success) {
  /* Processing variable qext */
  /* Processing variable qsca */
  /* Processing variable qgsa */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&radius,&refr_ind,&wavelength,&qext,&qsca,&qgsa);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("fff",qext,qsca,qgsa);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable qgsa */
  /* End of cleaning variable qsca */
  /* End of cleaning variable qext */
  } /*if (f2py_success) of wavelength*/
  /* End of cleaning variable wavelength */
  }  /*if (f2py_success) of refr_ind frompyobj*/
  /* End of cleaning variable refr_ind */
  } /*if (f2py_success) of radius*/
  /* End of cleaning variable radius */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of bhmie_driver ****************************/

/******************************* dmiess_driver *******************************/
static char doc_f2py_rout__mie_dmiess_module_dmiess_driver[] = "\
qscatc,qextc,asym = dmiess_driver(radius_shell_um,radius_core_um,refi_shell,refi_core,rad_lambda_um)\n\nWrapper for ``dmiess_driver``.\
\n\nParameters\n----------\n"
"radius_shell_um : input float\n"
"radius_core_um : input float\n"
"refi_shell : input complex\n"
"refi_core : input complex\n"
"rad_lambda_um : input float\n"
"\nReturns\n-------\n"
"qscatc : float\n"
"qextc : float\n"
"asym : float";
/*  */
static PyObject *f2py_rout__mie_dmiess_module_dmiess_driver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(double*,double*,complex_float*,complex_float*,double*,double*,double*,double*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  double radius_shell_um = 0;
  PyObject *radius_shell_um_capi = Py_None;
  double radius_core_um = 0;
  PyObject *radius_core_um_capi = Py_None;
  complex_float refi_shell;
  PyObject *refi_shell_capi = Py_None;
  complex_float refi_core;
  PyObject *refi_core_capi = Py_None;
  double rad_lambda_um = 0;
  PyObject *rad_lambda_um_capi = Py_None;
  double qscatc = 0;
  double qextc = 0;
  double asym = 0;
  static char *capi_kwlist[] = {"radius_shell_um","radius_core_um","refi_shell","refi_core","rad_lambda_um",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:_mie.dmiess_module.dmiess_driver",\
    capi_kwlist,&radius_shell_um_capi,&radius_core_um_capi,&refi_shell_capi,&refi_core_capi,&rad_lambda_um_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable radius_shell_um */
    f2py_success = double_from_pyobj(&radius_shell_um,radius_shell_um_capi,"_mie.dmiess_module.dmiess_driver() 1st argument (radius_shell_um) can't be converted to double");
  if (f2py_success) {
  /* Processing variable radius_core_um */
    f2py_success = double_from_pyobj(&radius_core_um,radius_core_um_capi,"_mie.dmiess_module.dmiess_driver() 2nd argument (radius_core_um) can't be converted to double");
  if (f2py_success) {
  /* Processing variable refi_shell */
    f2py_success = complex_float_from_pyobj(&refi_shell,refi_shell_capi,"_mie.dmiess_module.dmiess_driver() 3rd argument (refi_shell) can't be converted to complex_float");
  if (f2py_success) {
  /* Processing variable refi_core */
    f2py_success = complex_float_from_pyobj(&refi_core,refi_core_capi,"_mie.dmiess_module.dmiess_driver() 4th argument (refi_core) can't be converted to complex_float");
  if (f2py_success) {
  /* Processing variable rad_lambda_um */
    f2py_success = double_from_pyobj(&rad_lambda_um,rad_lambda_um_capi,"_mie.dmiess_module.dmiess_driver() 5th argument (rad_lambda_um) can't be converted to double");
  if (f2py_success) {
  /* Processing variable qscatc */
  /* Processing variable qextc */
  /* Processing variable asym */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&radius_shell_um,&radius_core_um,&refi_shell,&refi_core,&rad_lambda_um,&qscatc,&qextc,&asym);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("ddd",qscatc,qextc,asym);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable asym */
  /* End of cleaning variable qextc */
  /* End of cleaning variable qscatc */
  } /*if (f2py_success) of rad_lambda_um*/
  /* End of cleaning variable rad_lambda_um */
  }  /*if (f2py_success) of refi_core frompyobj*/
  /* End of cleaning variable refi_core */
  }  /*if (f2py_success) of refi_shell frompyobj*/
  /* End of cleaning variable refi_shell */
  } /*if (f2py_success) of radius_core_um*/
  /* End of cleaning variable radius_core_um */
  } /*if (f2py_success) of radius_shell_um*/
  /* End of cleaning variable radius_shell_um */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of dmiess_driver ****************************/

/******************************* dmilay_driver *******************************/
static char doc_f2py_rout__mie_dmilay_module_dmilay_driver[] = "\
Qext,Qsca,Qgsa = dmilay_driver(radius_shell,radius_core,shell_refr,core_refr,wavelength)\n\nWrapper for ``dmilay_driver``.\
\n\nParameters\n----------\n"
"radius_shell : input float\n"
"radius_core : input float\n"
"shell_refr : input complex\n"
"core_refr : input complex\n"
"wavelength : input float\n"
"\nReturns\n-------\n"
"Qext : float\n"
"Qsca : float\n"
"Qgsa : float";
/*  */
static PyObject *f2py_rout__mie_dmilay_module_dmilay_driver(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,complex_float*,complex_float*,float*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float radius_shell = 0;
  PyObject *radius_shell_capi = Py_None;
  float radius_core = 0;
  PyObject *radius_core_capi = Py_None;
  complex_float shell_refr;
  PyObject *shell_refr_capi = Py_None;
  complex_float core_refr;
  PyObject *core_refr_capi = Py_None;
  float wavelength = 0;
  PyObject *wavelength_capi = Py_None;
  float Qext = 0;
  float Qsca = 0;
  float Qgsa = 0;
  static char *capi_kwlist[] = {"radius_shell","radius_core","shell_refr","core_refr","wavelength",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOO:_mie.dmilay_module.dmilay_driver",\
    capi_kwlist,&radius_shell_capi,&radius_core_capi,&shell_refr_capi,&core_refr_capi,&wavelength_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable radius_shell */
    f2py_success = float_from_pyobj(&radius_shell,radius_shell_capi,"_mie.dmilay_module.dmilay_driver() 1st argument (radius_shell) can't be converted to float");
  if (f2py_success) {
  /* Processing variable radius_core */
    f2py_success = float_from_pyobj(&radius_core,radius_core_capi,"_mie.dmilay_module.dmilay_driver() 2nd argument (radius_core) can't be converted to float");
  if (f2py_success) {
  /* Processing variable wavelength */
    f2py_success = float_from_pyobj(&wavelength,wavelength_capi,"_mie.dmilay_module.dmilay_driver() 5th argument (wavelength) can't be converted to float");
  if (f2py_success) {
  /* Processing variable shell_refr */
    f2py_success = complex_float_from_pyobj(&shell_refr,shell_refr_capi,"_mie.dmilay_module.dmilay_driver() 3rd argument (shell_refr) can't be converted to complex_float");
  if (f2py_success) {
  /* Processing variable core_refr */
    f2py_success = complex_float_from_pyobj(&core_refr,core_refr_capi,"_mie.dmilay_module.dmilay_driver() 4th argument (core_refr) can't be converted to complex_float");
  if (f2py_success) {
  /* Processing variable Qext */
  /* Processing variable Qsca */
  /* Processing variable Qgsa */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&radius_shell,&radius_core,&shell_refr,&core_refr,&wavelength,&Qext,&Qsca,&Qgsa);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("fff",Qext,Qsca,Qgsa);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable Qgsa */
  /* End of cleaning variable Qsca */
  /* End of cleaning variable Qext */
  }  /*if (f2py_success) of core_refr frompyobj*/
  /* End of cleaning variable core_refr */
  }  /*if (f2py_success) of shell_refr frompyobj*/
  /* End of cleaning variable shell_refr */
  } /*if (f2py_success) of wavelength*/
  /* End of cleaning variable wavelength */
  } /*if (f2py_success) of radius_core*/
  /* End of cleaning variable radius_core */
  } /*if (f2py_success) of radius_shell*/
  /* End of cleaning variable radius_shell */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/**************************** end of dmilay_driver ****************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/

static FortranDataDef f2py_kinds_module_def[] = {
  {"test_double",-1,{{-1}},0,NULL,(void *)f2py_rout__mie_kinds_module_test_double,doc_f2py_rout__mie_kinds_module_test_double},
  {"test_complex",-1,{{-1}},0,NULL,(void *)f2py_rout__mie_kinds_module_test_complex,doc_f2py_rout__mie_kinds_module_test_complex},
  {NULL}
};

static void f2py_setup_kinds_module(char *test_double,char *test_complex) {
  int i_f2py=0;
  f2py_kinds_module_def[i_f2py++].data = test_double;
  f2py_kinds_module_def[i_f2py++].data = test_complex;
}
extern void F_FUNC_US(f2pyinitkinds_module,F2PYINITKINDS_MODULE)(void (*)(char *,char *));
static void f2py_init_kinds_module(void) {
  F_FUNC_US(f2pyinitkinds_module,F2PYINITKINDS_MODULE)(f2py_setup_kinds_module);
}


static FortranDataDef f2py_bhmie_module_def[] = {
  {"bhmie_driver",-1,{{-1}},0,NULL,(void *)f2py_rout__mie_bhmie_module_bhmie_driver,doc_f2py_rout__mie_bhmie_module_bhmie_driver},
  {NULL}
};

static void f2py_setup_bhmie_module(char *bhmie_driver) {
  int i_f2py=0;
  f2py_bhmie_module_def[i_f2py++].data = bhmie_driver;
}
extern void F_FUNC_US(f2pyinitbhmie_module,F2PYINITBHMIE_MODULE)(void (*)(char *));
static void f2py_init_bhmie_module(void) {
  F_FUNC_US(f2pyinitbhmie_module,F2PYINITBHMIE_MODULE)(f2py_setup_bhmie_module);
}


static FortranDataDef f2py_dmiess_module_def[] = {
  {"dmiess_driver",-1,{{-1}},0,NULL,(void *)f2py_rout__mie_dmiess_module_dmiess_driver,doc_f2py_rout__mie_dmiess_module_dmiess_driver},
  {NULL}
};

static void f2py_setup_dmiess_module(char *dmiess_driver) {
  int i_f2py=0;
  f2py_dmiess_module_def[i_f2py++].data = dmiess_driver;
}
extern void F_FUNC_US(f2pyinitdmiess_module,F2PYINITDMIESS_MODULE)(void (*)(char *));
static void f2py_init_dmiess_module(void) {
  F_FUNC_US(f2pyinitdmiess_module,F2PYINITDMIESS_MODULE)(f2py_setup_dmiess_module);
}


static FortranDataDef f2py_dmilay_module_def[] = {
  {"dmilay_driver",-1,{{-1}},0,NULL,(void *)f2py_rout__mie_dmilay_module_dmilay_driver,doc_f2py_rout__mie_dmilay_module_dmilay_driver},
  {NULL}
};

static void f2py_setup_dmilay_module(char *dmilay_driver) {
  int i_f2py=0;
  f2py_dmilay_module_def[i_f2py++].data = dmilay_driver;
}
extern void F_FUNC_US(f2pyinitdmilay_module,F2PYINITDMILAY_MODULE)(void (*)(char *));
static void f2py_init_dmilay_module(void) {
  F_FUNC_US(f2pyinitdmilay_module,F2PYINITDMILAY_MODULE)(f2py_setup_dmilay_module);
}

/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "_mie",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyMODINIT_FUNC PyInit__mie(void) {
#else
#define RETVAL
PyMODINIT_FUNC init_mie(void) {
#endif
  int i;
  PyObject *m,*d, *s;
#if PY_VERSION_HEX >= 0x03000000
  m = _mie_module = PyModule_Create(&moduledef);
#else
  m = _mie_module = Py_InitModule("_mie", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module _mie (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module '_mie' is auto-generated with f2py (version:2).\nFunctions:\n"
"Fortran 90/95 modules:\n""  kinds_module --- test_double(),test_complex()""  bhmie_module --- bhmie_driver()""  dmiess_module --- dmiess_driver()""  dmilay_module --- dmilay_driver()"".");
  PyDict_SetItemString(d, "__doc__", s);
  _mie_error = PyErr_NewException ("_mie.error", NULL, NULL);
  Py_DECREF(s);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++)
    PyDict_SetItemString(d, f2py_routine_defs[i].name,PyFortranObject_NewAsAttr(&f2py_routine_defs[i]));





/*eof initf2pywraphooks*/
  PyDict_SetItemString(d, "dmilay_module", PyFortranObject_New(f2py_dmilay_module_def,f2py_init_dmilay_module));
  PyDict_SetItemString(d, "dmiess_module", PyFortranObject_New(f2py_dmiess_module_def,f2py_init_dmiess_module));
  PyDict_SetItemString(d, "bhmie_module", PyFortranObject_New(f2py_bhmie_module_def,f2py_init_bhmie_module));
  PyDict_SetItemString(d, "kinds_module", PyFortranObject_New(f2py_kinds_module_def,f2py_init_kinds_module));
/*eof initf90modhooks*/

/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"_mie");
#endif

  return RETVAL;
}
#ifdef __cplusplus
}
#endif
